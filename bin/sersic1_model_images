#!/usr/bin/env python

# Create Sersic 1D model list, based on Simard parameters
#
# MRB 2014-12-07
# 

import pdb
import getopt
import os
import sys
import numpy as np
import astropy.io.fits as pyfits
import dimage
from dimage.dwcssimple import dwcssimple
from dimage.models import sersic1
from dimage.models import create_image as ci
from dimage import dfake
import random

def main(argv):
    # Defaults
    take=None
    modelname=None
    image_create=False

    # Parse header
    helpstr='sersic1d_model_list [-s seed] [-n number]'
    try:
        opts, args = getopt.getopt(argv,"iht:m:",
                                   ["image_create=", "help=","take=","modelname="])
    except getopt.GetoptError:
        print helpstr
        sys.exit(2)
    for opt, arg in opts:
        if opt == ("-h", "--help"):
            print helpstr;
            sys.exit()
        elif opt == ("-i"):
            image_create=True
        elif opt in ("-t", "--take"):
            take = arg
        elif opt in ("-m", "--modelname"):
            modelname = arg

    if(take is None):
        print "Must specify take with -t or --take"
        sys.exit()

    if(modelname is None):
        print "Must specify model name with -m or --modelname"
        sys.exit()

    # Read in model list
    data = sersic1.readpar(take, modelname)

    # Set length of data list
    # Override here for shorter run
    datalen = len(data)

    # Should this path generation go somewhere else as a function?
    dest = os.path.join(os.getenv('FAKEPHOTOMETRY'), take, 'fake', 'simard-sersic1')
    
    # Parse data and generate FITS image for each element
    for i in range(datalen):
        nx_i = data['nx'][i]
        ny_i = data['ny'][i]
        xcen_i = data['xcen'][i]
        ycen_i = data['ycen'][i]
        flux = data['flux'][i]
        r50_i = data['r50'][i]
        n_i = data['n'][i]
        phi_i = data['phi'][i]
        ba_i = data['ba'][i]

        # convert nx, ny to pixels from arcsec (5 pixel/arcsec)
        pixperarc = 5.
        r50_i = r50_i * pixperarc
        # generate wcs header to store resolution data
        
        # get size of image in degrees (from size nx_i in pixels)
        size = 1./pixperarc * (1./3600) * nx_i
        wcsheader = dwcssimple(180., 0., size, 1/pixperarc)[0]
        head = wcsheader.to_header()
        image_i = dfake(nx_i, ny_i, xcen=xcen_i, ycen=ycen_i, n=n_i, r50=r50_i, ba=ba_i, phi=phi_i, simple=False)
        
        hdu = pyfits.PrimaryHDU(image_i, header=head)
        imdest = os.path.join(dest, ('fake-' + str(i) + '.fits'))
        # clobber requires environment variable CLOBBER=1
        hdu.writeto(imdest, clobber=os.getenv('CLOBBER'))
        if image_create == True:
            ci.create_image(imdest, take, modelname, i)


if __name__ == "__main__": 
    try:
        main(sys.argv[1:])
    except:
        import sys
        tb = sys.exc_info()[2]
        pdb.post_mortem(tb)
